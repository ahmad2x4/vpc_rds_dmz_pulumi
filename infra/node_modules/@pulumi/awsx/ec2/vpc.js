"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const aws = require("@pulumi/aws");
const pulumi = require("@pulumi/pulumi");
const x = require("..");
const topology = require("./vpcTopology");
const utils = require("./../utils");
// Mapping from vpcId to Vpc.
const defaultVpcs = new Map();
class Vpc extends pulumi.ComponentResource {
    constructor(name, args = {}, opts = {}) {
        super("awsx:x:ec2:Vpc", name, {}, opts);
        // Convenience properties.  Equivalent to getting the IDs from teh corresponding XxxSubnets
        // properties.
        this.publicSubnetIds = [];
        this.privateSubnetIds = [];
        this.isolatedSubnetIds = [];
        this.publicSubnets = [];
        this.privateSubnets = [];
        this.isolatedSubnets = [];
        /**
         * The nat gateways created to allow private subnets access to the internet.
         * Only available if this was created using [VpcArgs].
         */
        this.natGateways = [];
        if (isExistingVpcArgs(args)) {
            this.vpc = args.vpc;
            this.id = this.vpc.id;
        }
        else {
            const cidrBlock = args.cidrBlock === undefined ? "10.0.0.0/16" : args.cidrBlock;
            const availabilityZones = getAvailabilityZones(this, args.numberOfAvailabilityZones);
            const numberOfNatGateways = args.numberOfNatGateways === undefined ? availabilityZones.length : args.numberOfNatGateways;
            const assignGeneratedIpv6CidrBlock = utils.ifUndefined(args.assignGeneratedIpv6CidrBlock, false);
            // We previously did not parent the underlying Vpc to this component. We now do. Provide
            // an alias so this doesn't cause resources to be destroyed/recreated for existing
            // stacks.
            this.vpc = new aws.ec2.Vpc(name, Object.assign(Object.assign({}, args), { cidrBlock, enableDnsHostnames: utils.ifUndefined(args.enableDnsHostnames, true), enableDnsSupport: utils.ifUndefined(args.enableDnsSupport, true), instanceTenancy: utils.ifUndefined(args.instanceTenancy, "default"), assignGeneratedIpv6CidrBlock }), { parent: this, aliases: [{ parent: pulumi.rootStackResource }] });
            this.id = this.vpc.id;
            const subnets = args.subnets || [
                { type: "public" },
                { type: "private" },
            ];
            this.partition(name, cidrBlock, availabilityZones, numberOfNatGateways, assignGeneratedIpv6CidrBlock, subnets, opts);
            // Create an internet gateway if we have public subnets.
            this.addInternetGateway(name, this.publicSubnets);
        }
        this.registerOutputs();
    }
    partition(name, cidrBlock, availabilityZones, numberOfNatGateways, assignGeneratedIpv6CidrBlock, subnetArgs, opts) {
        // Create the appropriate subnets.  Default to a single public and private subnet for each
        // availability zone if none were specified.
        const { subnets, natGateways, natRoutes } = topology.create(this, name, cidrBlock, this.vpc.ipv6CidrBlock, availabilityZones, numberOfNatGateways, assignGeneratedIpv6CidrBlock, subnetArgs);
        for (const desc of subnets) {
            // We previously did not parent the subnet to this component. We now do. Provide an
            // alias so this doesn't cause resources to be destroyed/recreated for existing
            // stacks.
            // Only set one of availabilityZone or availabilityZoneId
            const availabilityZone = desc.args.availabilityZone;
            const availabilityZoneId = availabilityZone ? undefined : desc.args.availabilityZoneId;
            const subnet = new x.ec2.Subnet(desc.subnetName, this, Object.assign(Object.assign({}, desc.args), { availabilityZone,
                availabilityZoneId, tags: utils.mergeTags({ type: desc.type, Name: desc.subnetName }, desc.args.tags) }), { aliases: [{ parent: opts.parent }], ignoreChanges: desc.ignoreChanges, parent: this });
            this.addSubnet(desc.type, subnet);
        }
        for (const desc of natGateways) {
            const publicSubnet = this.publicSubnets.find(s => s.subnetName === desc.publicSubnet);
            if (!publicSubnet) {
                throw new pulumi.ResourceError(`Could not find public subnet named ${desc.publicSubnet}`, this);
            }
            this.addNatGateway(desc.name, { subnet: publicSubnet });
        }
        for (const desc of natRoutes) {
            const privateSubnet = this.privateSubnets.find(s => s.subnetName === desc.privateSubnet);
            if (!privateSubnet) {
                throw new pulumi.ResourceError(`Could not find private subnet named ${desc.privateSubnet}`, this);
            }
            const natGateway = this.natGateways.find(g => g.natGatewayName === desc.natGateway);
            if (!natGateway) {
                throw new pulumi.ResourceError(`Could not find nat gateway named ${desc.natGateway}`, this);
            }
            privateSubnet.createRoute(desc.name, natGateway);
        }
    }
    addSubnet(type, subnet) {
        this.getSubnets(type).push(subnet);
        this.getSubnetIds(type).push(subnet.id);
    }
    getSubnets(type) {
        switch (type) {
            case "public": return this.publicSubnets;
            case "private": return this.privateSubnets;
            case "isolated": return this.isolatedSubnets;
            default: throw new Error("Unexpected subnet type: " + type);
        }
    }
    getSubnetIds(type) {
        switch (type) {
            case "public": return this.publicSubnetIds;
            case "private": return this.privateSubnetIds;
            case "isolated": return this.isolatedSubnetIds;
            default: throw new Error("Unexpected subnet type: " + type);
        }
    }
    /**
     * Adds an [awsx.ec2.InternetGateway] to this VPC.  Will fail if this Vpc already has an
     * InternetGateway.
     *
     * @param subnets The subnets to route the InternetGateway to.  Will default to the [public]
     *        subnets of this Vpc if not specified.
     */
    addInternetGateway(name, subnets, args = {}, opts = {}) {
        if (this.internetGateway) {
            throw new Error("Cannot add InternetGateway to Vpc that already has one.");
        }
        // See https://docs.aws.amazon.com/vpc/latest/userguide/VPC_Internet_Gateway.html#Add_IGW_Attach_Gateway
        // for more details.
        this.internetGateway = new x.ec2.InternetGateway(name, this, args, opts);
        subnets = subnets || this.publicSubnets;
        for (const subnet of subnets) {
            subnet.createRoute("ig", this.internetGateway);
        }
        return this.internetGateway;
    }
    /**
     * Adds an [awsx.ec2.NatGateway] to this VPC. The NatGateway must be supplied a subnet (normally
     * public) to be placed in.  After adding the NatGateway you should update the route table
     * associated with one or more of your private subnets to point Internet-bound traffic to the
     * NAT gateway. This enables instances in your private subnets to communicate with the internet.
     *
     * This can be done by calling [subnet.createRoute] and passing in the newly created NatGateway.
     */
    addNatGateway(name, args, opts = {}) {
        const natGateway = new x.ec2.NatGateway(name, this, args, opts);
        this.natGateways.push(natGateway);
        return natGateway;
    }
    /**
     * Gets the default vpc for the current aws account and region.
     *
     * See https://docs.aws.amazon.com/vpc/latest/userguide/default-vpc.html for more details.
     *
     * Note: the no-arg version of this call is not recommended.  It will acquire the default Vpc
     * for the current region and cache it.  Instead, it is recommended that the `getDefault(opts)`
     * version be used instead.  This version will properly respect providers.
     */
    static getDefault(opts = {}) {
        // Pull out the provider to ensure we're looking up the default vpc in the right location.
        // Note that we do not pass 'parent' along as we want the default vpc to always be parented
        // logically by hte stack.
        const provider = opts.provider ? opts.provider :
            opts.parent ? opts.parent.getProvider("aws::") : undefined;
        // And we want to be able to return the same Vpc object instance if it represents the same
        // logical default vpc instance for the AWS account.  Fortunately Vpcs have unique ids for
        // an account.  So we just map from the id to the Vpc instance we hydrate.  If asked again
        // for the same id we can just return the same instance.
        const vpcId = aws.ec2.getVpc({ default: true }, { provider }).id;
        let vpc = defaultVpcs.get(vpcId);
        if (!vpc) {
            // back compat.  We always would just use the first two public subnets of the region
            // we're in.  So preserve that, even though we could get all of them here.  Pulling in
            // more than the two we pulled in before could have deep implications for clients as
            // those subnets are used to make many downstream resource-creating decisions.
            const publicSubnetIds = aws.ec2.getSubnetIds({ vpcId }, { provider }).ids.slice(0, 2);
            // Generate the name as `default-` + the actual name.  For back compat with how we
            // previously named things, also create an alias from "default-vpc" to this name for
            // the very first default Vpc we create as that's how we used to name them.
            const vpcName = "default-" + vpcId;
            const aliases = defaultVpcs.size === 0
                ? [{ name: "default-vpc" }]
                : [];
            vpc = Vpc.fromExistingIds(vpcName, { vpcId, publicSubnetIds }, { aliases, provider });
            defaultVpcs.set(vpcId, vpc);
        }
        return vpc;
    }
    /**
     * Get an existing Vpc resource's state with the given name and IDs of its relevant
     * sub-resources. This will not cause a VPC (or any sub-resources) to be created, and removing
     * this Vpc from your pulumi application will not cause the existing cloud resource (or
     * sub-resources) to be destroyed.
     */
    static fromExistingIds(name, idArgs, opts) {
        const vpc = new Vpc(name, {
            vpc: aws.ec2.Vpc.get(name, idArgs.vpcId, {}, opts),
        }, opts);
        getExistingSubnets(vpc, name, "public", idArgs.publicSubnetIds);
        getExistingSubnets(vpc, name, "private", idArgs.privateSubnetIds);
        getExistingSubnets(vpc, name, "isolated", idArgs.isolatedSubnetIds);
        // Pass along aliases so that the previously unparented resources are now properly parented
        // to the vpc.
        if (idArgs.internetGatewayId) {
            const igName = `${name}-ig`;
            vpc.internetGateway = new x.ec2.InternetGateway(igName, vpc, {
                internetGateway: aws.ec2.InternetGateway.get(igName, idArgs.internetGatewayId, {}, { parent: vpc }),
            }, { parent: vpc, aliases: [{ parent: pulumi.rootStackResource }] });
        }
        if (idArgs.natGatewayIds) {
            for (let i = 0, n = idArgs.natGatewayIds.length; i < n; i++) {
                const natGatewayId = idArgs.natGatewayIds[i];
                const natName = `${name}-nat-${i}`;
                vpc.natGateways.push(new x.ec2.NatGateway(natName, vpc, {
                    natGateway: aws.ec2.NatGateway.get(natName, natGatewayId, {}, { parent: vpc }),
                }, { parent: vpc, aliases: [{ parent: pulumi.rootStackResource }] }));
            }
        }
        return vpc;
    }
}
exports.Vpc = Vpc;
Vpc.prototype.addInternetGateway.doNotCapture = true;
Vpc.prototype.addNatGateway.doNotCapture = true;
Vpc.prototype.partition.doNotCapture = true;
function getAvailabilityZones(vpc, requestedCount) {
    const result = aws.getAvailabilityZones(/*args:*/ undefined, { parent: vpc });
    if (result.names.length !== result.zoneIds.length) {
        throw new pulumi.ResourceError("Availability zones for region had mismatched names and ids.", vpc);
    }
    const descriptions = [];
    for (let i = 0, n = result.names.length; i < n; i++) {
        descriptions.push({ name: result.names[i], id: result.zoneIds[i] });
    }
    const count = typeof requestedCount === "number" ? requestedCount :
        requestedCount === "all" ? descriptions.length : 2;
    return descriptions.slice(0, count);
}
function shouldCreateNatGateways(vpc, numberOfNatGateways) {
    return vpc.privateSubnets.length > 0 && numberOfNatGateways > 0 && vpc.publicSubnets.length > 0;
}
function getExistingSubnets(vpc, vpcName, type, inputs = []) {
    const subnets = vpc.getSubnets(type);
    const subnetIds = vpc.getSubnetIds(type);
    for (let i = 0, n = inputs.length; i < n; i++) {
        const subnetName = `${vpcName}-${type}-${i}`;
        const subnet = new x.ec2.Subnet(subnetName, vpc, {
            subnet: aws.ec2.Subnet.get(subnetName, inputs[i], /*state:*/ undefined, { parent: vpc }),
        }, { parent: vpc });
        subnets.push(subnet);
        subnetIds.push(subnet.id);
    }
}
function isExistingVpcIdArgs(obj) {
    return !!obj.vpcId;
}
function isExistingVpcArgs(obj) {
    return !!obj.vpc;
}
// Make sure our exported args shape is compatible with the overwrite shape we're trying to provide.
const test1 = utils.checkCompat();
//# sourceMappingURL=vpc.js.map