import * as aws from "@pulumi/aws";
import * as cloudwatch from "../cloudwatch";
import { ApplicationLoadBalancer, ApplicationTargetGroup } from "./application";
import { NetworkLoadBalancer, NetworkTargetGroup } from "./network";
export declare namespace metrics {
    namespace application {
        interface ElasticLoadBalancingV2MetricChange extends cloudwatch.MetricChange {
            /**
             * Filters the metric data by load balancer.
             */
            loadBalancer?: aws.lb.LoadBalancer | ApplicationLoadBalancer;
            /**
             * Filters the metric data by target group.  If this is an [ApplicationTargetGroup] then
             * [loadBalancer] does not have to be provided.  If this is an
             * [aws.lb.TargetGroup] then [loadBalancer] must be provided.
             */
            targetGroup?: aws.lb.TargetGroup | ApplicationTargetGroup;
            /**
             * Filters the metric data by Availability Zone.
             */
            availabilityZone?: string;
        }
        /**
         * The total number of concurrent TCP connections active from clients to the load balancer
         * and from the load balancer to targets. Reporting criteria: There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions LoadBalancer
         */
        function activeConnectionCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of TLS connections initiated by the client that did not establish a session
         * with the load balancer. Possible causes include a mismatch of ciphers or protocols.
         * Reporting criteria: There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: AvailabilityZone, LoadBalancer
         */
        function clientTLSNegotiationErrorCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of load balancer capacity units (LCU) used by your load balancer. You pay for
         * the number of LCUs that you use per hour. For more information, see Elastic Load
         * Balancing Pricing. Reporting criteria: Always reported
         *
         * Statistics: All
         *
         * Dimensions: LoadBalancer
         */
        function consumedLCUs(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of fixed-response actions that were successful. Reporting criteria: There is a
         * nonzero value
         *
         * Statistics: The only meaningful statistic is Sum.
         *
         * Dimensions: LoadBalancer
         */
        function httpFixedResponseCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of redirect actions that were successful. Reporting criteria: There is a
         * nonzero value
         *
         * Statistics: The only meaningful statistic is Sum.
         *
         * Dimensions: LoadBalancer
         */
        function httpRedirectCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of redirect actions that couldn't be completed because the URL in the response
         * location header is larger than 8K. Reporting criteria: There is a nonzero value
         *
         * Statistics: The only meaningful statistic is Sum.
         *
         * Dimensions: LoadBalancer
         */
        function httpRedirectUrlLimitExceededCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP 3XX redirection codes that originate from the load balancer. Reporting
         * criteria: There is a nonzero value
         *
         * Statistics: The only meaningful statistic is Sum.
         *
         * Dimensions: LoadBalancer
         */
        function httpCodeELB3XXCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP 4XX client error codes that originate from the load balancer. Client
         * errors are generated when requests are malformed or incomplete. These requests have not
         * been received by the target. This count does not include any response codes generated by
         * the targets. Reporting criteria: There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum. Note that Minimum, Maximum, and Average all
         * return 1.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer
         */
        function httpCodeELB4XXCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP 5XX server error codes that originate from the load balancer. This
         * count does not include any response codes generated by the targets. Reporting criteria:
         * There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum. Note that Minimum, Maximum, and Average all
         * return 1.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer
         */
        function httpCodeELB5XXCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP 500 error codes that originate from the load balancer.
         *
         * Reporting criteria: There is a nonzero value
         *
         * Statistics: The only meaningful statistic is Sum.
         */
        function httpCodeELB500Count(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP 502 error codes that originate from the load balancer. Reporting
         * criteria: There is a nonzero value
         *
         * Statistics: The only meaningful statistic is Sum.
         */
        function httpCodeELB502Count(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP 503 error codes that originate from the load balancer. Reporting
         * criteria: There is a nonzero value
         *
         * Statistics: The only meaningful statistic is Sum.
         */
        function httpCodeELB503Count(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP 504 error codes that originate from the load balancer. Reporting
         * criteria: There is a nonzero value
         *
         * Statistics: The only meaningful statistic is Sum.
         */
        function httpCodeELB504Count(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of bytes processed by the load balancer over IPv6. Reporting criteria:
         * There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: LoadBalancer
         */
        function ipv6ProcessedBytes(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of IPv6 requests received by the load balancer. Reporting criteria: There is a
         * nonzero value
         *
         * Statistics: The most useful statistic is Sum. Note that Minimum, Maximum, and Average all
         * return 1.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function ipv6RequestCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of new TCP connections established from clients to the load balancer and
         * from the load balancer to targets. Reporting criteria: There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: LoadBalancer
         */
        function newConnectionCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of bytes processed by the load balancer over IPv4 and IPv6. Reporting
         * criteria: There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: LoadBalancer
         */
        function processedBytes(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of connections that were rejected because the load balancer had reached its
         * maximum number of connections. Reporting criteria: There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer
         */
        function rejectedConnectionCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of requests processed over IPv4 and IPv6. This count includes only the
         * requests with a response generated by a target of the load balancer. Reporting criteria:
         * Always reported
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function requestCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of rules processed by the load balancer given a request rate averaged over an
         * hour. Reporting criteria: There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: LoadBalancer
         */
        function ruleEvaluations(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of targets that are considered healthy. Reporting criteria: Reported if health
         * checks are enabled
         *
         * Statistics: The most useful statistics are Average, Minimum, and Maximum.
         *
         * Dimensions:          TargetGroup, LoadBalancer TargetGroup, AvailabilityZone,
         * LoadBalancer
         */
        function healthyHostCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP response codes generated by the targets. This does not include any
         * response codes generated by the load balancer. Reporting criteria: There is a nonzero
         * value
         *
         * Statistics: The most useful statistic is Sum. Note that Minimum, Maximum, and Average all
         * return 1.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function httpCodeTarget2XXCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP response codes generated by the targets. This does not include any
         * response codes generated by the load balancer. Reporting criteria: There is a nonzero
         * value
         *
         * Statistics: The most useful statistic is Sum. Note that Minimum, Maximum, and Average all
         * return 1.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function httpCodeTarget3XXCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP response codes generated by the targets. This does not include any
         * response codes generated by the load balancer. Reporting criteria: There is a nonzero
         * value
         *
         * Statistics: The most useful statistic is Sum. Note that Minimum, Maximum, and Average all
         * return 1.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function httpCodeTarget4XXCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of HTTP response codes generated by the targets. This does not include any
         * response codes generated by the load balancer. Reporting criteria: There is a nonzero
         * value
         *
         * Statistics: The most useful statistic is Sum. Note that Minimum, Maximum, and Average all
         * return 1.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function httpCodeTarget5XXCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of requests where the load balancer chose a new target because it couldn't use
         * an existing sticky session. For example, the request was the first request from a new
         * client and no stickiness cookie was presented, a stickiness cookie was presented but it
         * did not specify a target that was registered with this target group, the stickiness
         * cookie was malformed or expired, or an internal error prevented the load balancer from
         * reading the stickiness cookie. Reporting criteria: Stickiness is enabled on the target
         * group.
         *
         * Statistics: The only meaningful statistic is Sum.
         */
        function nonStickyRequestCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The average number of requests received by each target in a target group. You must
         * specify the target group using the TargetGroup dimension. This metric does not apply if
         * the target is a Lambda function. Reporting criteria: Always reported
         *
         * Statistics: The only valid statistic is Sum. Note that this represents the average not
         * the sum.
         *
         * Dimensions: TargetGroup TargetGroup, LoadBalancer
         */
        function requestCountPerTarget(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of connections that were not successfully established between the load
         * balancer and target. This metric does not apply if the target is a Lambda function.
         * Reporting criteria: There is a nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function targetConnectionErrorCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The time elapsed, in seconds, after the request leaves the load balancer until a response
         * from the target is received. This is equivalent to the target_processing_time field in
         * the access logs. Reporting criteria: There is a nonzero value
         *
         * Statistics: The most useful statistics are Average and pNN.NN (percentiles).
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function targetResponseTime(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of TLS connections initiated by the load balancer that did not establish a
         * session with the target. Possible causes include a mismatch of ciphers or protocols. This
         * metric does not apply if the target is a Lambda function. Reporting criteria: There is a
         * nonzero value
         *
         * Statistics: The most useful statistic is Sum.
         *
         * Dimensions: LoadBalancer AvailabilityZone, LoadBalancer TargetGroup, LoadBalancer
         * TargetGroup, AvailabilityZone, LoadBalancer
         */
        function targetTLSNegotiationErrorCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of targets that are considered unhealthy. Reporting criteria: Reported if
         * health checks are enabled
         *
         * Statistics: The most useful statistics are Average, Minimum, and Maximum.
         *
         * Dimensions: TargetGroup, LoadBalancer TargetGroup, AvailabilityZone, LoadBalancer
         */
        function unHealthyHostCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
    }
    namespace network {
        interface ElasticLoadBalancingV2MetricChange extends cloudwatch.MetricChange {
            /**
             * Filters the metric data by load balancer.
             */
            loadBalancer?: aws.lb.LoadBalancer | NetworkLoadBalancer;
            /**
             * Filters the metric data by target group.  If this is a [NetworkTargetGroup] then
             * [loadBalancer] does not have to be provided.  If this is an
             * [aws.lb.TargetGroup] then [loadBalancer] must be provided.
             */
            targetGroup?: aws.lb.TargetGroup | NetworkTargetGroup;
            /**
             * Filters the metric data by Availability Zone.
             */
            availabilityZone?: string;
        }
        /**
         * The total number of concurrent flows (or connections) from clients to targets. This
         * metric includes connections in the SYN_SENT and ESTABLISHED states. TCP connections are
         * not terminated at the load balancer, so a client opening a TCP connection to a target
         * counts as a single flow.
         *
         * Statistics: The most useful statistics are Average, Maximum, and Minimum.
         */
        function activeFlowCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of concurrent TLS flows (or connections) from clients to targets. This
         * metric includes only connections in the ESTABLISHED states.
         *
         * Statistics: The most useful statistics are Average, Maximum, and Minimum.
         */
        function activeFlowCount_TLS(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of TLS handshakes that failed during negotiation between a client and a
         * TLS listener.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function clientTLSNegotiationErrorCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of load balancer capacity units (LCU) used by your load balancer. You pay for
         * the number of LCUs that you use per hour. For more information, see Elastic Load
         * Balancing Pricing.
         */
        function consumedLCUs(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of targets that are considered healthy.
         *
         * Statistics: The most useful statistics are Maximum and Minimum.
         */
        function healthyHostCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of new flows (or connections) established from clients to targets in the
         * time period.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function newFlowCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of new TLS flows (or connections) established from clients to targets in
         * the time period.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function newFlowCountTLS(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of bytes processed by the load balancer, including TCP/IP headers.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function processedBytes(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of bytes processed by TLS listeners.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function processedBytesTLS(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of TLS handshakes that failed during negotiation between a TLS listener
         * and a target.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function targetTLSNegotiationErrorCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of reset (RST) packets sent from a client to a target. These resets are
         * generated by the client and forwarded by the load balancer.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function tcpClientResetCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of reset (RST) packets generated by the load balancer.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function tcpELBResetCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The total number of reset (RST) packets sent from a target to a client. These resets are
         * generated by the target and forwarded by the load balancer.
         *
         * Statistics: The most useful statistic is Sum.
         */
        function tcpTargetResetCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
        /**
         * The number of targets that are considered unhealthy.
         *
         * Statistics: The most useful statistics are Maximum and Minimum.
         */
        function unhealthyHostCount(change?: ElasticLoadBalancingV2MetricChange): cloudwatch.Metric;
    }
}
