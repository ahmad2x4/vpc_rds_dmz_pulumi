"use strict";
// Copyright 2016-2018, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const aws = require("@pulumi/aws");
const pulumi = require("@pulumi/pulumi");
const errors_1 = require("@pulumi/pulumi/errors");
const aws_1 = require("./aws");
const utils_1 = require("./utils");
// The lazily initialized default network instance.
let defaultNetwork;
/**
 * Network encapsulates the configuration of an Amazon VPC.  Both [VPC with Public
 * Subnet](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Scenario1.html) and [VPC with Public and Private
 * Subnets (NAT)](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Scenario2.html) configurations are
 * supported.
 *
 * @deprecated Usages of awsx.Network should be migrated to awsx.ec2.Vpc.
 */
class Network extends pulumi.ComponentResource {
    constructor(name, mergedArgs = {}, opts = {}) {
        super("awsx:network:Network", name, {}, opts);
        // IDEA: default to the number of availability zones in this region, rather than 2.  To do this requires
        // invoking the provider, which requires that we "go async" at a very inopportune time here.  When
        // pulumi/pulumi#331 lands, this will be much easier to do, and we can improve this situation.
        const parentOpts = { parent: this };
        const vpcArgs = mergedArgs;
        if (vpcArgs.vpcId) {
            this.vpcId = pulumi.output(vpcArgs.vpcId);
            this.subnetIds = vpcArgs.subnetIds.map(id => pulumi.output(id));
            this.usePrivateSubnets = vpcArgs.usePrivateSubnets;
            this.securityGroupIds = vpcArgs.securityGroupIds.map(id => pulumi.output(id));
            this.publicSubnetIds = vpcArgs.publicSubnetIds.map(id => pulumi.output(id));
            return;
        }
        const args = mergedArgs;
        const numberOfAvailabilityZones = args.numberOfAvailabilityZones || 2;
        if (numberOfAvailabilityZones < 1 || numberOfAvailabilityZones > 4) {
            throw new errors_1.RunError(`Unsupported number of availability zones for network: ${numberOfAvailabilityZones}`);
        }
        const tags = { Name: name };
        this.usePrivateSubnets = args.usePrivateSubnets || false;
        const vpc = new aws.ec2.Vpc(name, {
            cidrBlock: utils_1.ifUndefined(args.cidrBlock, "10.10.0.0/16"),
            enableDnsHostnames: utils_1.ifUndefined(args.enableDnsHostnames, true),
            enableDnsSupport: utils_1.ifUndefined(args.enableDnsSupport, true),
            tags,
        }, parentOpts);
        this.vpcId = vpc.id;
        this.securityGroupIds = [vpc.defaultSecurityGroupId];
        this.subnetIds = [];
        this.publicSubnetIds = [];
        const internetGateway = new aws.ec2.InternetGateway(name, {
            vpcId: vpc.id,
            tags,
        }, parentOpts);
        const publicRouteTable = new aws.ec2.RouteTable(name, {
            vpcId: vpc.id,
            routes: [{
                    cidrBlock: "0.0.0.0/0",
                    gatewayId: internetGateway.id,
                }],
            tags,
        }, parentOpts);
        this.publicRouteTableId = publicRouteTable.id;
        for (let i = 0; i < numberOfAvailabilityZones; i++) {
            const subnetName = `${name}-${i}`;
            // Create the subnet for this AZ - either - either public or private
            const subnet = new aws.ec2.Subnet(subnetName, {
                vpcId: vpc.id,
                availabilityZone: aws_1.getAvailabilityZone(i),
                cidrBlock: `10.10.${i}.0/24`,
                mapPublicIpOnLaunch: !this.usePrivateSubnets,
                tags: { Name: subnetName },
            }, parentOpts);
            // We will use a different route table for this subnet depending on
            // whether we are in a public or private subnet
            const subnetRouteTable = createSubnetRouteTable(this, publicRouteTable, subnet, name, i);
            const routeTableAssociation = new aws.ec2.RouteTableAssociation(`${name}-${i}`, {
                subnetId: subnet.id,
                routeTableId: subnetRouteTable.id,
            }, parentOpts);
            // Record the subnet id, but depend on the RouteTableAssociation
            const subnetId = pulumi.all([subnet.id, routeTableAssociation.id]).apply(([id]) => id);
            this.subnetIds.push(subnetId);
        }
    }
    /**
     * Gets the default VPC for the AWS account as a Network.  This first time this is called, the
     * default network will be lazily created, using whatever options are provided in opts. All
     * subsequent calls will return that same network even if different opts are provided.
     */
    static getDefault(opts) {
        if (!defaultNetwork) {
            const vpc = aws.ec2.getVpc({ default: true });
            const vpcId = vpc.id;
            const subnetIds = aws.ec2.getSubnetIds({ vpcId }).ids;
            const defaultSecurityGroup = aws.ec2.getSecurityGroup({ name: "default", vpcId }).id;
            const subnet0 = subnetIds[0];
            const subnet1 = subnetIds[1];
            defaultNetwork = this.fromVpc("default-vpc", {
                vpcId: vpcId,
                subnetIds: [subnet0, subnet1],
                usePrivateSubnets: false,
                securityGroupIds: [defaultSecurityGroup],
                publicSubnetIds: [subnet0, subnet1],
            }, opts);
        }
        return defaultNetwork;
    }
    /**
     * Creates a new network using the configuration values of an existing VPC.
     */
    static fromVpc(name, vpcArgs, opts) {
        if (!vpcArgs.vpcId) {
            throw new errors_1.RunError("vpcArgs.vpcId must be provided.");
        }
        if (!vpcArgs.subnetIds) {
            throw new errors_1.RunError("vpcArgs.subnetIds must be provided.");
        }
        if (!vpcArgs.securityGroupIds) {
            throw new errors_1.RunError("vpcArgs.securityGroupIds must be provided.");
        }
        if (!vpcArgs.publicSubnetIds) {
            throw new errors_1.RunError("vpcArgs.publicSubnetIds must be provided.");
        }
        return new Network(name, vpcArgs, opts);
    }
}
exports.Network = Network;
function createSubnetRouteTable(network, publicRouteTable, subnet, name, index) {
    const parentOpts = { parent: network };
    if (!network.usePrivateSubnets) {
        // The subnet is public, so register it as our public subnet
        network.publicSubnetIds.push(subnet.id);
        return publicRouteTable;
    }
    // We need a public subnet for the NAT Gateway
    const natName = `${name}-nat-${index}`;
    const tags = { Name: natName };
    const natGatewayPublicSubnet = new aws.ec2.Subnet(natName, {
        vpcId: network.vpcId,
        availabilityZone: aws_1.getAvailabilityZone(index),
        cidrBlock: `10.10.${index + 64}.0/24`,
        mapPublicIpOnLaunch: true,
        tags,
    }, parentOpts);
    // And we need to route traffic from that public subnet to the Internet Gateway
    const natGatewayRoutes = new aws.ec2.RouteTableAssociation(natName, {
        subnetId: natGatewayPublicSubnet.id,
        routeTableId: publicRouteTable.id,
    }, parentOpts);
    // Record the subnet id, but depend on the RouteTableAssociation
    const natGatewayPublicSubnetId = pulumi.all([natGatewayPublicSubnet.id, natGatewayRoutes.id]).apply(([id]) => id);
    network.publicSubnetIds.push(natGatewayPublicSubnetId);
    // We need an Elastic IP for the NAT Gateway
    const eip = new aws.ec2.Eip(natName, {}, parentOpts);
    // And we need a NAT Gateway to be able to access the Internet
    const natGateway = new aws.ec2.NatGateway(natName, {
        subnetId: natGatewayPublicSubnet.id,
        allocationId: eip.id,
        tags,
    }, parentOpts);
    const natRouteTable = new aws.ec2.RouteTable(natName, {
        vpcId: network.vpcId,
        routes: [{
                cidrBlock: "0.0.0.0/0",
                natGatewayId: natGateway.id,
            }],
        tags,
    }, parentOpts);
    // Route through the NAT gateway for the private subnet
    return natRouteTable;
}
//# sourceMappingURL=network.js.map